# 穴なぞり機能リファクタリング

## 現状の問題

### 元の実装（修正前）
```java
// HolePreview内でなぞり判定
cube.getCubeWallPositions(wallLocation)
    .filter(worldPos -> PlayerCube.isAir(...))  // 問題：壁の穴以外も含まれる
    .forEach(worldPos -> {
        currentlyTracedHoles.add(holeKey);
    });
```

**バグ:**
- キューブの投影位置が空気かチェックしているが、壁の穴以外の座標も含まれる
- なぞった穴に無効な座標が記録される
- 完了判定が誤動作する

## 正しい設計

### 責任の分離

#### HoleTracingManager（状態管理クラス）
**責任:**
- 現在の壁の穴位置を記録
- なぞった穴の追跡
- 完了状態の管理

**提供するメソッド:**
```java
// 壁の設定
void setCurrentWall(int wallZ, Set<String> allHoles)

// 穴をなぞったとマーク
void markHoleTraced(String holeKey)

// 状態の取得
boolean isCurrentWall(int wallZ)
boolean isCompleted()
Set<String> getAllHoles()
Set<String> getTracedHoles()

// リセット・クリア
void reset()
void clear()
```

**特徴:**
- 純粋な状態管理
- エフェクトや音は扱わない
- ロジックは含まない（判定は呼び出し側が行う）

#### HolePreview（表示・判定クラス）
**責任:**
- プレビューパネルの表示
- **なぞり判定のロジック**
- エフェクトと音の再生

**処理の流れ:**
```java
// 1. 壁を設定
if (!tracingManager.isCurrentWall(wallZ)) {
    Set<String> allHoles = 壁の5x5範囲から穴を検出();
    tracingManager.setCurrentWall(wallZ, allHoles);
}

// 2. なぞり判定（HolePreviewが行う）
if (緑の状態 && !tracingManager.isCompleted()) {
    Set<String> allHoles = tracingManager.getAllHoles();
    Set<String> tracedHoles = tracingManager.getTracedHoles();
    Set<String> cubePositions = キューブの投影位置;

    // ★重要：全穴とキューブ位置の共通部分のみ
    allHoles.stream()
        .filter(cubePositions::contains)
        .filter(hole -> !tracedHoles.contains(hole))
        .forEach(hole -> {
            tracingManager.markHoleTraced(hole);
            showTraceEffect(hole);  // エフェクト表示
        });

    // 完了判定もHolePreviewが行う
    if (tracingManager.isCompleted()) {
        showCompleteEffect();
    }
}
```

## 設計の利点

### 1. シンプル
- `HoleTracingManager`は状態を保持するだけ
- コールバック不要
- 各クラスの責任が明確

### 2. 自然な処理の流れ
- なぞり判定のロジックが`HolePreview`にある（本来あるべき場所）
- エフェクト表示も`HolePreview`で完結
- 毎フレーム`updateTracing`を呼ぶ必要がない

### 3. テスタブル
- `HoleTracingManager`は純粋な状態管理なのでテストしやすい
- モックやコールバックが不要

## データ構造

### HoleTracingManager
```java
private Integer currentWallZ;       // 現在の壁のZ座標
private Set<String> allHoles;       // 全穴の座標
private Set<String> tracedHoles;    // なぞった穴の座標
```

**特徴:**
- 1つの壁のみ追跡（プレイヤーは常に1つの壁しか見ない）
- Mapは不要
- シンプルな状態保持

## 修正内容

### バグの根本修正
```java
// 修正前（誤り）
cube.getCubeWallPositions(wallLocation)
    .filter(worldPos -> PlayerCube.isAir(...))  // 壁の穴以外も含まれる

// 修正後（正しい）
Set<String> allHoles = tracingManager.getAllHoles();
Set<String> cubePositions = キューブの投影位置;

allHoles.stream()
    .filter(cubePositions::contains)  // 全穴とキューブの共通部分のみ
```

### 完了判定
```java
// HoleTracingManager内で自動判定
public boolean isCompleted() {
    return tracedHoles.size() == allHoles.size()
        && allHoles.containsAll(tracedHoles);
}
```

## 実装方針

### 1. HoleTracingManagerのシンプル化
- `updateTracing`メソッドを削除
- 状態管理メソッドのみ提供
- コールバック削除

### 2. HolePreviewの責任明確化
- なぞり判定ロジックをHolePreviewに配置
- エフェクト表示も完全にHolePreviewで管理
- `tracingManager`は状態の取得・設定のみ使用

### 3. メソッド名
- `setCurrentWall()` - 現在の壁を設定
- `isCurrentWall()` - 指定した壁が現在の壁か
- `isCompleted()` - 完了したか
- `markHoleTraced()` - 穴をなぞったとマーク
- `getAllHoles()` - 全穴を取得
- `getTracedHoles()` - なぞった穴を取得
- `reset()` - リセット
- `clear()` - クリア

## 参考：仕様

### なぞり判定の仕様
- **条件**: 緑プレビュー状態（キューブ全体が通れる）
- **判定**: 全穴とキューブ投影の共通部分
- **エフェクト**: 初めてなぞった時のみ（`HOLE_TRACE`音 + パーティクル）
- **完了**: 全穴をなぞった時（`HOLE_COMPLETE`音）

### リセットタイミング
- 白→緑の変化（失敗後の再挑戦）
- 穴から出た時（通過後の再挑戦）
