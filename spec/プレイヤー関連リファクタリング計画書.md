# プレイヤー関連リファクタリング計画書

## 概要
現在のコードでは、Player、プレイヤーのUUID、PlayerDataの3種類のプレイヤー表現が混在しており、引数の一貫性が取れていない状況です。このリファクタリングでは、PlayerDataを中心とした統一的なプレイヤー管理システムに変更します。

## 現状の問題点

### 1. プレイヤー表現の混在
- **Player**: BukkitのPlayerオブジェクト（直接的なプレイヤー操作）
- **UUID**: プレイヤーの一意識別子（PlayerDataManagerのキー）
- **PlayerData**: ゲーム状態を管理するデータクラス

### 2. 引数の不統一
- `PlayerDataManager.getPlayerData(UUID playerId)` - UUIDを引数に取る
- `GameManager.startGame(Player player)` - Playerを引数に取る
- `PlayerGameListener`内でPlayerとUUIDを混在して使用

### 3. PlayerDataの制限
- PlayerDataにPlayerオブジェクトが含まれていない
- プレイヤー情報にアクセスする際に毎回UUIDからPlayerを取得する必要がある

## リファクタリング方針

### 1. PlayerDataの拡張
```java
public class PlayerData {
    public Player player; // 新規追加：Playerオブジェクトを保持
    // 既存のフィールド...
}
```

### 2. PlayerDataManagerの変更
- `getPlayerData(UUID playerId)` → `getPlayerData(Player player)`
- `getOrCreatePlayerData(UUID playerId)` → `getOrCreatePlayerData(Player player)`
- 取得時にPlayerData.playerを更新（リログ対応）

### 3. メソッド引数の統一
- プレイヤー関連の処理では原則としてPlayerDataを引数に取る
- PlayerDataからPlayerにアクセスする場合は`playerData.player`を使用

## 実装計画

### Phase 1: PlayerDataクラスの拡張
**対象ファイル**: `src/main/java/mods/kpw/runthroughhole/player/PlayerData.java`

**変更内容**:
1. Playerフィールドの追加
2. コンストラクタでPlayerを設定するオーバーロード追加

```java
public class PlayerData {
    public Player player; // 新規追加
    
    public PlayerData() {
        // 既存のコンストラクタ
    }
    
    public PlayerData(Player player) {
        this.player = player;
        // 既存の初期化処理
    }
}
```

### Phase 2: PlayerDataManagerの変更
**対象ファイル**: `src/main/java/mods/kpw/runthroughhole/player/PlayerDataManager.java`

**変更内容**:
1. メソッドシグネチャの変更
2. PlayerData.playerの更新処理追加

```java
public class PlayerDataManager {
    // UUIDベースのメソッドをPlayerベースに変更
    public PlayerData getPlayerData(Player player) {
        PlayerData data = playerDataMap.get(player.getUniqueId());
        if (data != null) {
            data.player = player; // Playerオブジェクトを更新
        }
        return data;
    }
    
    public PlayerData getOrCreatePlayerData(Player player) {
        return playerDataMap.computeIfAbsent(player.getUniqueId(), k -> {
            PlayerData newData = new PlayerData(player);
            return newData;
        });
    }
    
    // 既存のUUIDベースメソッドは互換性のため残す（非推奨）
    @Deprecated
    public PlayerData getPlayerData(UUID playerId) {
        // 実装は残すが非推奨とする
    }
}
```

### Phase 3: GameManagerの変更
**対象ファイル**: `src/main/java/mods/kpw/runthroughhole/game/GameManager.java`

**変更内容**:
1. メソッド引数をPlayerDataに変更
2. PlayerDataからPlayerにアクセスする処理に変更

```java
public class GameManager {
    // 変更前
    public void startGame(Player player) { ... }
    public void stopGame(Player player) { ... }
    public void gameOver(Player player, String reason) { ... }
    
    // 変更後
    public void startGame(PlayerData playerData) { ... }
    public void stopGame(PlayerData playerData) { ... }
    public void gameOver(PlayerData playerData, String reason) { ... }
}
```

### Phase 4: PlayerGameListenerの変更
**対象ファイル**: `src/main/java/mods/kpw/runthroughhole/player/PlayerGameListener.java`

**変更内容**:
1. PlayerDataの取得方法を変更
2. PlayerDataからPlayerにアクセスする処理に統一

```java
public class PlayerGameListener {
    // 変更前
    PlayerData data = mainPlugin.getPlayerDataManager().getPlayerData(player.getUniqueId());
    
    // 変更後
    PlayerData data = mainPlugin.getPlayerDataManager().getPlayerData(player);
    // PlayerDataからPlayerにアクセス: data.player
}
```

### Phase 5: RunHoleCommandの変更
**対象ファイル**: `src/main/java/mods/kpw/runthroughhole/RunHoleCommand.java`

**変更内容**:
1. GameManagerのメソッド呼び出しを変更
2. PlayerからPlayerDataを取得して渡す

```java
public class RunHoleCommand {
    // 変更前
    plugin.getGameManager().startGame(target);
    
    // 変更後
    PlayerData playerData = plugin.getPlayerDataManager().getOrCreatePlayerData(target);
    plugin.getGameManager().startGame(playerData);
}
```

## 影響範囲

### 変更が必要なファイル
1. `PlayerData.java` - Playerフィールド追加
2. `PlayerDataManager.java` - メソッドシグネチャ変更
3. `GameManager.java` - 引数をPlayerDataに変更
4. `PlayerGameListener.java` - PlayerDataの取得方法変更
5. `RunHoleCommand.java` - GameManager呼び出し変更

### 互換性の考慮
- UUIDベースのメソッドは非推奨として残す
- 段階的な移行を可能にする

## 期待される効果

### 1. コードの一貫性向上
- プレイヤー関連の処理でPlayerDataを統一して使用
- 引数の型が統一され、メソッド呼び出しが明確になる

### 2. パフォーマンス向上
- UUIDからPlayerを取得する処理が不要になる
- PlayerDataにPlayerが含まれるため、直接アクセス可能

### 3. 保守性向上
- プレイヤー情報の管理が一元化される
- リログ時のPlayerオブジェクト更新が自動化される

### 4. 型安全性向上
- PlayerDataを引数に取ることで、ゲーム状態の有無が保証される
- nullチェックの範囲が明確になる

## 実装順序

1. **PlayerDataクラスの拡張** - 基盤となる変更
2. **PlayerDataManagerの変更** - データ管理層の変更
3. **GameManagerの変更** - ゲームロジック層の変更
4. **PlayerGameListenerの変更** - イベント処理層の変更
5. **RunHoleCommandの変更** - コマンド処理層の変更
6. **テストとビルド** - 動作確認

## 注意事項

### 1. リログ対応
- PlayerData.playerは毎回更新する必要がある
- プレイヤーがオフラインの場合、Playerオブジェクトが無効になる可能性がある

### 2. メモリ管理
- PlayerDataにPlayerオブジェクトを保持することで、メモリ使用量が増加する
- プレイヤーがオフラインになった際の適切なクリーンアップが必要

### 3. 並行性
- PlayerData.playerの更新はスレッドセーフである必要がある
- ゲームループでのPlayerDataアクセス時の安全性を確保する

## 完了後の検証項目

1. **ビルドテスト** - コンパイルエラーがないことを確認
2. **機能テスト** - ゲーム開始・終了が正常に動作することを確認
3. **リログテスト** - プレイヤーがリログした際の動作を確認
4. **メモリテスト** - メモリリークがないことを確認
5. **並行性テスト** - 複数プレイヤー同時ゲーム時の動作を確認
