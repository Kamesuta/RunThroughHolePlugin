# スコアボード統合・コマンドブロック制御 仕様書

## 概要
RunThroughHoleプラグインのゲームイベントをスコアボード（Objective）と統合し、コマンドブロックでのゲーム制御（タイムアタック、スコア競争など）を可能にします。

## 設計方針
- Minecraftのスコアボード機能を活用し、コマンドブロックから簡単にゲーム状態を検知できるようにする
- すべてのObjective名は `runhole_` プレフィックスで始める
- イベント発生時にスコアを自動更新し、コマンドブロックで `execute if score` 等で判定可能にする
- プレイヤー単位でスコアを管理し、マルチプレイヤー対応

## Objective一覧

### 1. runhole_game_state
**説明**: プレイヤーのゲーム状態を示す
- `0`: ゲーム未参加
- `1`: ゲーム参加中
- `2`: ゲーム終了

**用途**:
- プレイヤーがゲーム中か、終了しているかを判定
- ゲーム開始・終了時の処理トリガー

**更新タイミング**:
- `startGame()`: 0 → 1
- `gameOver()`, `stopGame()`, `playerQuit()`: 1 → 2
- ゲームから完全に退出、スコア等リセット時: 2 → 0

---

### 2. runhole_end_type
**説明**: ゲームの終了理由を示す
- `0`: 未設定
- `1`: ゲームオーバー（壁との衝突）
- `2`: `/rth stop` コマンドによる強制停止
- `3`: Shiftキーによる自主退出
- `4`: ログアウトによる終了

**用途**:
- 終了理由に応じたメッセージや演出の分岐
- リザルト画面のカスタマイズ

**更新タイミング**:
- `startGame()`: 0にリセット
- `gameOver()` を呼んでいる箇所: 1に設定 (gameOverは複数箇所から呼ばれるため、呼び出し元で設定)
- `/rth stop` 実行時: 2に設定
- Shiftキーで退出時: 3に設定
- ログアウト時: 4に設定

---

### 3. runhole_walls_passed
**説明**: 通過した壁の数（距離スコア）

**用途**:
- プレイヤーの到達距離を記録
- ランキング表示
- タイムアタックでの進行度確認

**更新タイミング**:
- 壁を通過するたび +1
- `startGame()`: 0にリセット

**実装箇所**:
`PlayerCube.checkCollision()` で壁を通過したことを検知し、GameManagerに通知

---

### 4. runhole_holes_traced
**説明**: なぞった穴の数

**用途**:
- 穴なぞり達成度の確認
- パーフェクトクリアの判定

**更新タイミング**:
- 穴をなぞるたび +1
- `startGame()`: 0にリセット

**実装箇所**:
`HoleTracingManager.markHoleTraced()` 呼び出し時

---

### 5. runhole_perfect_walls
**説明**: すべての穴をなぞって通過した壁の数（パーフェクト通過）

**用途**:
- パーフェクトプレイの評価
- ボーナススコア計算

**更新タイミング**:
- 壁通過時、`HoleTracingManager.isCompleted()` が true の場合 +1
- `startGame()`: 0にリセット

**実装箇所**:
`PlayerCube.checkCollision()` で壁通過を検知し、`HoleTracingManager` の状態を確認

---

### 6. runhole_move_count
**説明**: 移動操作回数（WASD入力）

**用途**:
- 操作頻度の分析
- 効率プレイの評価

**更新タイミング**:
- WASD入力時 +1
- `startGame()`: 0にリセット

**実装箇所**:
`PlayerCube.move()` 系メソッド呼び出し時

---

### 7. runhole_rotation_count
**説明**: 回転操作回数

**用途**:
- 操作頻度の分析
- 回転制限チャレンジ

**更新タイミング**:
- キューブ回転時 +1
- `startGame()`: 0にリセット

**実装箇所**:
`PlayerCube.rotate()` 系メソッド呼び出し時

---

### 8. runhole_is_boosting
**説明**: ブースト中フラグ
- `0`: ブーストしていない
- `1`: ブースト中

**用途**:
- リアルタイムでブースト状態を検知
- ブースト中の演出トリガー

**更新タイミング**:
- `startBoosting()`: 0 → 1
- `stopBoosting()`: 1 → 0
- `startGame()`: 0にリセット

**実装箇所**:
`PlayerCube.startBoosting()` / `stopBoosting()`

---

## ゲームイベント一覧

### イベント1: onGameStart
**発生タイミング**: `GameManager.startGame()` 呼び出し時

**スコアボード更新**:
- `runhole_game_state` = 1
- `runhole_end_type` = 0
- `runhole_walls_passed` = 0
- `runhole_holes_traced` = 0
- `runhole_perfect_walls` = 0
- `runhole_move_count` = 0
- `runhole_rotation_count` = 0
- `runhole_is_boosting` = 0

**コマンドブロック連携例**:
```
execute as @a[scores={runhole_game_state=1}] run tellraw @s {"text":"ゲーム開始！","color":"green"}
```

---

### イベント2: onGameEnd
**発生タイミング**: ゲームが何らかの理由で終了した時 (`gameOver`, `stopGame`, `playerQuit`)

**スコアボード更新**:
- `runhole_game_state` = 2
- `runhole_is_boosting` = 0
- `runhole_end_type` に終了理由を設定 (1:衝突, 2:コマンド, 3:Shift, 4:ログアウト)

**コマンドブロック連携例**:
```
# 衝突によるゲームオーバー
execute as @a[scores={runhole_game_state=2,runhole_end_type=1}] run title @s title {"text":"GAME OVER","color":"red"}
execute as @a[scores={runhole_game_state=2,runhole_end_type=1}] run playsound minecraft:entity.ender_dragon.death master @s

# Shiftキーによる終了
execute as @a[scores={runhole_game_state=2,runhole_end_type=3}] run tellraw @s {"text":"ゲームを終了しました","color":"yellow"}

# 管理者による停止
execute as @a[scores={runhole_game_state=2,runhole_end_type=2}] run tellraw @s {"text":"管理者によってゲームが停止されました","color":"red"}
```

**実装箇所**:
- `GameManager.gameOver()`: `runhole_end_type` = 1
- `GameManager.stopGame()`: `runhole_end_type` = 2
- `PlayerGameListener` (Shift/Logout): `runhole_end_type` = 3 or 4

---

### イベント3: onWallPassed
**発生タイミング**: 壁を無事に通過した時

**スコアボード更新**:
- `runhole_walls_passed` += 1
- `runhole_perfect_walls` += 1（全穴なぞり済みの場合）

**コマンドブロック連携例**:
```
execute as @a[scores={runhole_walls_passed=10}] run tellraw @s {"text":"10枚目の壁を突破！","color":"gold"}
execute as @a[scores={runhole_perfect_walls=5}] run effect give @s minecraft:speed 5 1
```

**新規実装必要**:
- `PlayerCube` に壁通過検知ロジックを追加
- 現在のZ座標と前回のZ座標を比較し、壁の間隔（例: 10ブロック）を超えたら通過とみなす

---

### イベント4: onHoleTraced
**発生タイミング**: 穴をなぞった時

**スコアボード更新**:
- `runhole_holes_traced` += なぞった穴の数

**コマンドブロック連携例**:
```
execute as @a[scores={runhole_holes_traced=50..}] run title @s actionbar {"text":"50個の穴をなぞった！","color":"aqua"}
```

**実装箇所**:
`HoleTracingManager.markHoleTraced()` が呼ばれた時に、追加された穴の数をカウント

---

### イベント5: onAllHolesTraced
**発生タイミング**: 壁のすべての穴をなぞり終えた時

**スコアボード更新**:
- なし（状態のみ）

**コマンドブロック連携例**:
```
execute as @a if score @s runhole_holes_traced = @s runhole_current_wall_holes run playsound minecraft:entity.player.levelup master @s
```

**実装箇所**:
`HoleTracingManager.isCompleted()` が false → true に変化した時

**追加提案Objective**:
- `runhole_current_wall_holes`: 現在の壁の穴の総数（比較用）

---

### イベント6: onMove
**発生タイミング**: プレイヤーが移動操作した時

**スコアボード更新**:
- `runhole_move_count` += 1

**コマンドブロック連携例**:
```
execute as @a[scores={runhole_move_count=100..}] run title @s actionbar {"text":"100回移動！","color":"aqua"}
```

**実装箇所**:
`PlayerCube.move()` 系メソッド

---

### イベント7: onRotation
**発生タイミング**: キューブを回転させた時

**スコアボード更新**:
- `runhole_rotation_count` += 1

**コマンドブロック連携例**:
```
execute as @a[scores={runhole_rotation_count=50..}] run tellraw @s {"text":"回転しすぎ！","color":"yellow"}
```

**実装箇所**:
`PlayerCube.rotate()` 系メソッド

---

### イベント8: onBoostStart
**発生タイミング**: ブースト開始時

**スコアボード更新**:
- `runhole_is_boosting` = 1

**コマンドブロック連携例**:
```
execute as @a[scores={runhole_is_boosting=1}] run particle minecraft:flame ~ ~ ~ 0.3 0.3 0.3 0.05 10
```

**実装箇所**:
`PlayerCube.startBoosting()`

---

### イベント9: onBoostEnd
**発生タイミング**: ブースト終了時

**スコアボード更新**:
- `runhole_is_boosting` = 0

**コマンドブロック連携例**:
```
execute as @a[scores={runhole_is_boosting=0}] run particle minecraft:smoke ~ ~ ~ 0.2 0.2 0.2 0.01 5
```

**実装箇所**:
`PlayerCube.stopBoosting()`

---

## 実装計画

### フェーズ1: スコア管理クラスの作成
1. `GameScoreTracker` クラスを作成（名前重複を避ける）
   - Objectiveの初期化
   - スコア更新メソッドの提供
   - プレイヤー別スコア管理

### フェーズ2: GameManagerへの統合
1. 各イベント発生時に `GameScoreTracker` を呼び出す
2. ゲーム開始時にスコアを初期化
3. ゲーム終了時にスコアをクリーンアップ

### フェーズ3: 壁通過検知の実装
1. `PlayerCube` に壁通過ロジックを追加
2. `GameManager` に通知する仕組みを実装

### フェーズ4: テストとドキュメント
1. 各イベントの動作確認
2. コマンドブロック連携例のドキュメント作成
3. サンプルコマンドの提供

---

## コマンドブロック連携例

### 壁数チャレンジモード
```
# ゴール地点（10枚の壁を突破）
/execute as @a[scores={runhole_walls_passed=10,runhole_game_state=1}] run tellraw @s [{"text":"クリア！ 10枚の壁を突破！","color":"gold"}]
/execute as @a[scores={runhole_walls_passed=10,runhole_game_state=1}] run tag @s add runhole_cleared
```

### パーフェクトチャレンジモード
```
# パーフェクト通過でボーナス演出
/execute as @a[scores={runhole_perfect_walls=5..}] run effect give @s minecraft:speed 5 1
/execute as @a[scores={runhole_perfect_walls=5..}] run title @s actionbar {"text":"5回連続パーフェクト！","color":"gold"}
```

### 回転制限モード
```
# 回転数制限（30回まで）
/execute as @a[scores={runhole_rotation_count=30..,runhole_game_state=1}] run tellraw @s {"text":"回転数オーバー！","color":"red"}
/execute as @a[scores={runhole_rotation_count=30..,runhole_game_state=1}] run tag @s add runhole_rotation_failed
```

---

## 技術的注意事項

1. **スコアボードのクリーンアップ**
   - プラグイン無効化時にObjectiveを削除しない（データ永続化）
   - 必要に応じて `/scoreboard objectives remove runhole_*` で手動削除

2. **マルチプレイヤー対応**
   - すべてのスコアはプレイヤー単位で管理
   - 同時に複数人がプレイ可能

3. **パフォーマンス考慮**
   - スコア更新は軽量な操作
   - イベント駆動で必要な時のみ更新

4. **後方互換性**
   - 既存のゲームロジックに影響を与えない
   - スコアボード機能は常に有効

---

## まとめ

この仕様により、RunThroughHoleプラグインは以下のことが可能になります：

1. **柔軟なゲームモード作成**: コマンドブロックで独自ルールのゲームを作成可能
2. **リアルタイム統計**: プレイ中の統計をリアルタイムで確認・表示
3. **イベント駆動の演出**: スコアに応じた自動演出やギミックの実装
4. **ランキングシステム**: スコアボードを活用した順位表示
5. **データ分析**: プレイスタイルの分析や改善点の把握

コマンドブロック製作者やサーバー管理者にとって、カスタマイズ性の高いミニゲーム環境を提供できます。
